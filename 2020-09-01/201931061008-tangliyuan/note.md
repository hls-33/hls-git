# 第一天笔记

## 入门篇

-  JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如`Array`、`Date`、`Math`等）。 

-  avaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。 

- 脚本语言：不需要编译，运行过程中由js解释器逐行进行解释并执行。

- js很像Java的脚本语言，Js语法比java自由的多。

- 声明用 `var` ，没赋值就是`undefined`，不写`var`也行。没有类型限制，随时可以改变类型。

-  `console.log（）`可以在控制台显示。

- 标识符命名规则： 第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母）， 以及美元符号（`$`）和下划线（`_`）。  ； 第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字`0-9`。 **关键字不能用来命名。**

-  此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以 **<!--** 和 **-->**也被视为合法的单行注释。  **需要注意的是，`-->`只有在行首，才会被当成单行注释，否则会当作正常的运算。**

-  淆赋值表达式（`=`）、严格相等运算符（`===`）（值和数据类型要一模一样才能全等）和相等运算符（`==`）。  

- 三元运算符： 如果“条件”为`true`，则返回“表达式1”的值，否则返回“表达式2”的值。 

  ```
  (条件) ? 表达式1 : 表达式2
  ```

-  `continue`语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。 

-  JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。 

  ```
  label:
    语句
  ```

   标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。 

   标签通常与`break`语句和`continue`语句配合使用，跳出特定的循环。

## 数据类型

### 概述

JavaScript 的数据类型，共有六种：

- 数值（number）：整数和小数（比如`1`和`3.14`）
- 字符串（string）：文本（比如`Hello World`）。
- 布尔值（boolean）：表示真伪的两个特殊值，即`true`（真）和`false`（假）
- `undefined`：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值
- `null`：表示空值，即此处的值为空。
- 对象（object）：各种值组成的集合。

 数值、字符串、布尔值这三种类型，合称为**原始类型**（primitive type）的值，即它们是最基本的数据类型 。 对象则称为**合成类型**（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于`undefined`和`null`，一般将它们看成两个**特殊值**。 

对象是最复杂的数据类型，又可以分成三个子类型。

- 狭义的对象（object）
- 数组（array）
- 函数（function）

JavaScript 有三种方法，可以确定一个值到底是什么类型。

- `typeof`运算符
- `instanceof`运算符
- `Object.prototype.toString`方法

 数值、字符串、布尔值分别返回`number`、`string`、`boolean`。  函数返回`function`。  `undefined`返回`undefined`。  `null`返回`object`。 

### null , undefined 和 布尔值

 区别：`null`是一个表示“空”的对象，转为数值时为`0`；`undefined`是一个表示"此处无定义"的原始值，转为数值时为`NaN`。

如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为`false`，其他值都视为`true`。

- `undefined`
- `null`
- `false`
- `0`
- `NaN`
- `""`或`''`（空字符串）

###  数值

 JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，`1`与`1.0`是相同的，是同一个数。  由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。 

精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即-253到253，都可以精确表示。 所以简单的法则就是，JavaScript **对15位的十进制数都可以精确处理**。

 也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为2的1024次方到2的-1023次方（开区间），超出这个范围的数无法表示。  一个数小于等于2的-1075次方   “负向溢出”，即 JavaScript 无法表示这么小的数，这时会直接返回0。 

 JavaScript 提供`Number`对象的`MAX_VALUE`和`MIN_VALUE`属性，返回可以表示的具体的**最大值和最小值。** 

 以下两种情况，JavaScript 会自动将数值转为**科学计数法表示**，其他情况都采用字面形式直接表示：

 **（1）小数点前的数字多于21位。** 

 **（2）小数点后的零多于5个。** 

JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。

- 十进制：没有前导0的数值。
- 八进制：有前缀`0o`或`0O`的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。
- 十六进制：有前缀`0x`或`0X`的数值。
- 二进制：有前缀`0b`或`0B`的数值。

默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。

 JavaScript 内部实际上存在2个`0`：一个是`+0`，一个是`-0`，区别就是64位浮点数表示法的符号位不同。它们是等价的。  除以正零得到`+Infinity`，除以负零得到`-Infinity`，这两者是不相等的 。 `Infinity`表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到`Infinity`。  `Infinity`大于一切数值（除了`NaN`），`-Infinity`小于一切数值（除了`NaN`）。 

 **`NaN`是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。** 

 `NaN`不等于任何值，包括它本身。 

 `NaN`与任何数（包括它自己）的运算，得到的都是`NaN`。 

 `parseInt`方法用于将**字符串转为整数**。 `parseInt`的参数都是字符串，结果只返回字符串头部可以转为数字的部分。如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回`NaN`。

 `parseFloat`方法用于将一个字符串转为**浮点数**。 如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回`NaN`。  `parseFloat`会将空字符串转为`NaN`。 

 `isNaN`方法可以用来判断一个值是否为`NaN`。  但是，对于空数组和只有一个数值成员的数值，`isNaN`返回`false`。 

 `isFinite`方法返回一个**布尔值**，表示某个值是否为正常的数值。 

### 字符串

 字符串默认只能写在一行内，分成多行将会报错。 

 连接运算符（`+`）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。 

 反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。 

- `\0` ：null（`\u0000`）
- `\b` ：后退键（`\u0008`）
- `\f` ：换页符（`\u000C`）
- `\n` ：换行符（`\u000A`）
- `\r` ：回车键（`\u000D`）
- `\t` ：制表符（`\u0009`）
- `\v` ：垂直制表符（`\u000B`）
- `\'` ：单引号（`\u0027`）
- `\"` ：双引号（`\u0022`）
- `\\` ：反斜杠（`\u005C`）

 如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。 

 但是，字符串与数组的相似性仅此而已。实际上，**无法改变字符串之中的单个字符**。 

 `length`属性返回字符串的长度，该属性也是无法改变的。 

 JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。 

 每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。  对于码点在`U+10000`到`U+10FFFF`之间的字符，JavaScript 总是认为它们是**两个字符**（`length`属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。 

JavaScript 原生提供两个 Base64 相关的方法。

- `btoa()`：任意值转为 Base64 编码
- `atob()`：Base64 编码转为原来的值

 **注意，这两个方法不适合非 ASCII 码的字符，会报错。**

 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 

```
function b64Encode(str) {
  return btoa(encodeURIComponent(str));
}

function b64Decode(str) {
  return decodeURIComponent(atob(str));
}

b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"
b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好"
```

###  对象

 对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。 

 如果键名是数值，会被自动转为字符串。  如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。 

 如果没有圆括号，`eval`将其理解为一个代码块；加上圆括号以后，就理解成一个对象。 

 读取对象的**属性**，有**两种方法**，一种是使用点运算符，还有一种是使用方括号运算符。  **注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。** 

 查看一个对象本身的所有属性，可以使用`Object.keys`方法。 

 `delete`命令用于删除对象的属性，删除成功后返回`true`。  **注意**，删除一个不存在的属性，`delete`不报错，而且返回`true`。  `delete`命令只能删除对象本身的属性，无法删除继承的属性 。

 使用对象的`hasOwnProperty`方法判断一下，是否为对象自身的属性。 

 `for...in`循环用来遍历一个对象的全部属性。 

- 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。
- 它不仅遍历对象自身的属性，还遍历继承的属性。

 `with`语句的作用是操作同一个对象的多个属性时，提供一些书写的方便。  **注意**，如果`with`区块内部有变量的赋值操作，**必须是当前对象已经存在的属性**，否则会创造一个当前作用域的全局变量。  因此，建议不要使用`with`语句，可以考虑用一个**临时变量**代替`with`。 

 对象的`valueOf`方法总是返回对象自身 

 JavaScript 有三种声明函数的方法 ：

1.  `function`命令声明的代码区块，就是一个函数。 
2.  除了用`function`命令声明函数，还可以采用变量赋值的写法。 
3.  第三种声明函数的方式是`Function`构造函数。 

 采用`function`命令和`var`赋值语句声明同一个函数，由于存在函数提升，最后会采用`var`赋值语句的定义。 

函数的`name`属性返回函数的名字。 

 函数的`length`属性返回函数预期传入的参数个数，即函数定义之中的参数个数。 

 函数的`toString()`方法返回一个字符串，内容是函数的源码。  函数内部的注释也可以返回。

 **`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。**  

 **函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。** 

 函数参数不是必需的，JavaScript 允许省略参数。 

 如果有同名的参数，则取最后出现的那个值。 

 `arguments`对象包含了函数运行时的**所有参数**，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。  修改`arguments`对象不会影响到实际的函数参数。 

 将`arguments`转为真正的数组 ， 两种常用的转换方法 ：

 **`slice`方法**和**逐一填入新数组**。 

```
var args = Array.prototype.slice.call(arguments);

// 或者
var args = [];
for (var i = 0; i < arguments.length; i++) {
  args.push(arguments[i]);
}
```

 `arguments`对象带有一个`callee`属性，返回它所对应的原函数。 



 由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把**闭包**简单理解成“**定义在一个函数内部的函数**”。 

 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以**使得它诞生环境一直存在**。 所以，闭包可以看作是函数内部作用域的一个接口。  闭包的另一个用处，是**封装对象的私有属性和私有方法**。 

 如果`function`关键字出现在行首，一律解释成语句。因此，引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。 解决方法就是不要让`function`出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。  

 上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“**立即调用的函数表达式**”（Immediately-Invoked Function Expression），简称 IIFE。 目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 

 `eval`命令接受一个字符串作为参数，并将这个字符串当作语句执行。  如果`eval`的参数不是字符串，那么会原样返回。  应该有独自存在的意义 。

 为了保证`eval`的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行`eval`，`eval`内部一律是**全局作用域**。 

### 数组

 如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到`length`设置的值。 

 当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。 

 使用`delete`命令删除一个数组成员，会形成空位，并且不会影响`length`属性。 

 数组的`slice`方法可以将“类似数组的对象”变成真正的数组。 

```
var arr = Array.prototype.slice.call(arrayLike);
```



## 运算符

### 算数运算符

 **指数运算符**：`x ** y` 

加法运算符，会变成字符串。

  余数运算符（`%`）返回前一个运算子被后一个运算子除，所得的余数 ，运算结果的正负号由第一个运算子的正负号决定。 

 自增和自减运算符有一个需要注意的地方，就是放在**变量之后**，会先返回变量**操作前**的值，再进行自增/自减操作；放在**变量之前**，会**先进行自增/自减操作**，再返回变量操作后的值。 

### 比较运算符

JavaScript 一共提供了8个比较运算符。

- `>` 大于运算符
- `<` 小于运算符
- `<=` 小于或等于运算符
- `>=` 大于或等于运算符
- `==` 相等运算符
- `===` 严格相等运算符
- `!=` 不相等运算符
- `!==` 严格不相等运算符

 **任何值（包括`NaN`本身）与`NaN`比较，返回的都是`false`。** 

 JavaScript 提供两种相等运算符：`==`和`===`：

 相等运算符（`==`）比较两个值是否相等，严格相等运算符（`===`）比较它们是否为“同一个值”。如果两个值**不是同一类型**，严格相等运算符（`===`）直接返回`false`，而相等运算符（`==`）会将它们转换成**同一个类型**，再用严格相等运算符进行比较。  **正`0`严等于负`0`。**  **`undefined`和`null`与自身严格相等。** 

 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。 对于两个对象的比较，严格相等运算符比较的是**地址**，而大于或小于运算符比较的是**值**。 

 **因此建议不要使用相等运算符（`==`），最好只使用严格相等运算符（`===`）。** 

### 布尔运算符

布尔运算符用于将表达式转为布尔值，一共包含四个运算符。

- 取反运算符：`!`
- 且运算符：`&&`
- 或运算符：`||`
- 三元运算符：`?:`

### 二进制位运算符

二进制位运算符用于直接对二进制位进行计算，一共有7个。

- **二进制或运算符**（or）：符号为`|`，表示若两个二进制位都为`0`，则结果为`0`，否则为`1`。
- **二进制与运算符**（and）：符号为`&`，表示若两个二进制位都为1，则结果为1，否则为0。
- **二进制否运算符**（not）：符号为`~`，表示对一个二进制位取反。
- **异或运算符**（xor）：符号为`^`，表示若两个二进制位不相同，则结果为1，否则为0。
- **左移运算符**（left shift）：符号为`<<`， 将一个数的二进制值向左移动指定的位数，尾部补`0`，即乘以`2`的指定次方。向左移动的时候，最高位的符号位是一起移动的。 
- **右移运算符**（right shift）：符号为`>>`， 将一个数的二进制值向右移动指定的位数。如果是正数，头部全部补`0`；如果是负数，头部全部补`1`。右移运算符基本上相当于除以`2`的指定次方（最高位即符号位参与移动）。 
- **头部补零的右移运算符**（zero filled right shift）：符号为`>>>`， 就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位。所以，该运算总是得到正值。 

 位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分。 

 二进制否运算符（`~`）将每个二进制位都变为相反值（`0`变为`1`，`1`变为`0`）。它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制。 

 “异或运算”有一个特殊运用，连续对两个数`a`和`b`进行三次异或运算，`a^=b; b^=a; a^=b;`，可以**交换**它们的值。这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值。  异或运算也可以用来取整。 

### 其他运算符、运算顺序

`void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`。 这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转。 

 根据语言规格，这五个运算符的优先级从高到低依次为：小于等于（`<=`)、严格相等（`===`）、或（`||`）、三元（`?:`）、等号（`=`）。因此上面的表达式，实际的运算顺序如下。 

 少数运算符是“右结合”，其中最主要的是赋值运算符（`=`）和三元条件运算符（`?:`）。 指数运算符（`**`）也是右结合。